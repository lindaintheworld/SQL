-- DAY10

-- DDL

-- 제약조건(CONSTRAINTS) : 테이블 만들 때 설정
-- 이 테이블에는 어떠한 값만 입력할 수 있다는 조건을 달아준다.
-- NOT NULL : 반드시 값을 입력해야 하는 컬럼, 빈칸이면 안됨 -->에러 처리 해야 함, 예외적으로 얘만 컬럼 레벨에서 정의 가능
-- UNIQUE : 값이 중복되면 안 된다. EX) 사번, 주민등록번호 등
-- PRIMARY KEY : 테이블의 기본 키로 사용할 컬럼 지정, 반드시 설정해야 하는 것은 아니다. 테이블 당 1개만 가능
--                      NOT NULL + UNIQUE, NULL 상태면 안 된다. 값을 정확하게 찾아내기 위해서....
-- REFERENCES : 외래 키, 참조 키, 제공되는 값만 사용하는 컬럼, 테이블과 테이블외 관계를 맺는다
--                      EX) 직급, 부서 
-- CHECK : WHERE 절 같이 조건을 건다. 위배 조건에 합당한 내용만 입력함 EX) 급여에는 양수만 입력해야 한다 등, 조건에 위배되면 에러
--              EX) 결혼 여부에는 대문자 Y 또는 대문자 N만 기록 가능
-- 제약 조건 : 객체로 DICTIONARY에 저장됨, ALTER TABLE로 제약 조건 수정하기 위해서 제약 조건에 이름을 달아준다, 
--              이름을 지정하지 않으면 프로그램에서 자동으로 달아줌

-- DROP TABLE COUNTRY CASCADE CONSTRAINTS; 
-- 테이블 지울 때 제약조건도 함께 삭제해라(CASCADE)
-- COUNTRY_NAME VARCHAR2(30) NOT NULL : 컬럼레벨
-- CONSTRAINT FK_CTRID FOREIGN KEY(COUNTRY_ID : 사용자) REFERENCES COUNTRY : 테이블 레벨
-- FK_CTRID 얘가 이름

-- 1. NOT NULL
-- 컬럼에 값이 반드시 기록되어야 할 때 설정 (웹에서의 필수 입력 항목을 뜻함)
-- 컬럼 레벨에서만 설정할 수 있음.

CREATE TABLE TESTNN (
    NNID NUMBER(5) NOT NULL, --컬럼레벨
    NN_NAME VARCHAR(20) 
);

-- 값 기록 테스트
INSERT INTO TESTNN(NNID, NN_NAME)
VALUES (NULL, NULL); -- ERROR
-- NNID에 NOT NULL 제약조건 위배됨.

INSERT INTO TESTNN -- 컬럼명 생략되면, 테이블의 모든 컬럼에 값 기록해야함
VALUES (1, NULL); -- 테이블의 컬럼 생성 순서와 자료형 맞춰서 값 기록 나열함

SELECT *  FROM TESTNN;

INSERT INTO TESTNN (NN_NAME)
VALUES ('ORACLE'); -- 생략된 컬럼은 자동 NULL 처리됨 >> 에러 

-- 테이블 레벨에 NOT NULL 적용시
CREATE TABLE TESTNN2(
    NN_ID NUMBER(5) CONSTRAINT T2_NNID NOT NULL,
    NN_NAME VARCHAR2(10)--, 
    -- 테이블 레벨
    --[ CONSTRAINT 제약조건이름] 제약조건종류 (적용할 컬럼명)
    -- CONSTRAINT T2_NNNAME NOT NULL (NN_NMAE)
);

--2. UNIQUE
-- 해당 컬럼의 중복값(같은값) 입력을 막겠다는 의미의 제약조건임
-- 설정하면 같은 값은 두번 기록 못하는 컬럼이 됨
-- 컬럼레벌, 테이블레벌 둘 다 설정할 수 있음
-- 복합키로도 설정할 수 있음

CREATE TABLE TESTUN(
    UN_ID CHAR(3) UNIQUE,
    UN_NAME VARCHAR2(10) NOT NULL
);

-- 기록 테스트
INSERT INTO TESTUN VALUES('AAA', 'ORACLE');
INSERT INTO TESTUN VALUES('AAA', 'JAVA'); --UNIQUE 제약 조건 위배됨 >>에러

SELECT * FROM TESTUN;

CREATE TABLE TESTUN2 (
    UN_ID CHAR(3) CONSTRAINT T2_UNID UNIQUE,
    UN_NAME VARCHAR2(10) CONSTRAINT T2_UNNAME NOT NULL  
);

CREATE TABLE TESTUN3 (
    UN_ID CHAR(3),
    UN_NAME VARCHAR2(10) NOT NULL,
    CONSTRAINT T3_UNID UNIQUE (UN_ID)
);

-- 3. PRIMARY KEY
-- 테이블에서 한 행의 정보를 찾기 위해 쓸 수 있는 값이 기록된 컬럼에 적용함.
-- NOT NULL + UNIQUE
-- 한 테이블에 한 번만 사용할 수 있음

CREATE TABLE TESTPK(
    PK_ID  NUMBER PRIMARY KEY,
    PK_NAME VARCHAR2(15) NOT NULL,
    PK_DATE DATE
);

-- 기록 테스트
INSERT INTO TESTPK VALUES (1, '홍길동', '15/03/12');
INSERT INTO TESTPK VALUES (NULL, '박문수', SYSDATE); -- 에러 : NOT NULL 제약조건 위배
INSERT INTO TESTPK VALUES (1, '박문수', SYSDATE); -- 에러 : UNIQUE 제약조건 위배
INSERT INTO TESTPK VALUES (2, '박문수', SYSDATE);

SELECT * FROM TESTPK;

-- 테이블당 한 번만 설정할 수 있음
CREATE TABLE TESTPK2 (
    PID NUMBER PRIMARY KEY,
    PNAME VARCHAR2(15) PRIMARY KEY -- "table can have only one primary key"
    );
    
-- 컬럼레벨에서 설정
CREATE TABLE TESTPK2(
    PID NUMBER CONSTRAINT P2_PID PRIMARY KEY,
    PNAME VARCHAR2(15),
    PDATE DATE
);

-- 테이블레벨에서 설정
CREATE TABLE TESTPK3(
    PID NUMBER,
    PNAME VARCHAR2(15),
    PDATE DATE,
    CONSTRAINT T3_PID PRIMARY KEY (PID)
);

-- 4. CHECK
-- 컬럼에 기록되는 값에 대한 조건 설정을 하는 제약조건임.
-- CHECK (컬럼명 연산자 비교값)
-- 비교값은 고정값이어야함. 바뀌는 값이면 에러남.

CREATE TABLE TESTCHK (
    C_NAME VARCHAR2(15) CONSTRAINT TCK_NAME NOT NULL,
    C_PRICE NUMBER(5) CHECK (C_PRICE BETWEEN 1 AND 99999),
    C_LEVEL CHAR(1) CHECK (C_LEVEL IN ('A', 'B', 'C'))
);

INSERT INTO TESTCHK VALUES ('갤럭시 S9', 65000, 'A');
INSERT INTO TESTCHK VALUES ('LG G7', 125000, 'A'); -- ERROR : CHECK 제약 조건 위배, value larger than specified precision allowed for this column
INSERT INTO TESTCHK VALUES ('LG G7', 0, 'A'); -- ERROR
INSERT INTO TESTCHK VALUES ('LG G7', 65300, 'D'); -- ERROR : CHECK 제약 조건 위배, check constraint (STUDENT.SYS_C007197) violated

--연습문제

CREATE TABLE CONSTRAITN_EMP(
    EID CHAR(3) CONSTRAINT PKEID PRIMARY KEY,
    ENAME VARCHAR2(20) CONSTRAINT NENAME NOT NULL,
    ENO CHAR(14) CONSTRAINT NENO NOT NULL CONSTRAINT UENO UNIQUE,
    EMAIL VARCHAR2(25) CONSTRAINT UEMAIL UNIQUE,
    PHONE VARCHAR2(12),
    HIRE_DATE DATE DEFAULT SYSDATE,
    JID CHAR(2) CONSTRAINT FKJID REFERENCES JOB ON DELETE SET NULL,
    SALARY NUMBER,
    BONUS_PCT NUMBER,
    MARRIAGE CHAR(1) DEFAULT 'N' CONSTRAINT CHK CHECK (MARRIAGE IN ('Y', 'N')),
    MID CHAR(3) CONSTRAINT FKMID REFERENCES CONSTRAINT_EMP ON DELETE SET NULL,
    DID CHAR(2),
    CONSTRAINT FKDID FOREIGN KEY (DID) REFERENCES DEPARTMENT ON DELETE CASCADE
);

CREATE TABLE TESTCHK2 (
    C_NAME VARCHAR2(15) PRIMARY KEY,
    C_PRICE NUMBER(5) CHECK (C_PRICE >= 1 AND C_PRICE <= 99999),
    C_LEVEL CHAR(1) CHECK (C_LEVEL = 'A' OR C_LEVEL ='B' OR C_LEVEL = 'C'),
    --C_DATE DATE CHECK (C_DATE < SYSDATE)
    --비교값은 반드시 리터럴(값) 사용, 바뀌는 값은 사용 못 함
    --C_DATE DATE CHECK(C_DATE < TO_DATE('16/01/01', 'RR/MM/DD'))
    C_DATE DATE CHECK(C_DATE < TO_DATE('16/01/01', 'YYYY/MM/DD')) -- BUG!!!! 이렇게 하면 안됌
);

-- 5. FOREIGN KEY : 참조 테이블의 PRIMARY KEY/UNIQUE 제약조건이 설정된 컬럼만 참조 가능
-- 외래키, 외부키
-- 다른 테이블에서 제공하는 값만 사용할 수 있는 컬럼을 의미함
-- 제공되지 않는 값 사용하면 에러남
-- 컬럼 레벨에서 설정
-- [CONSTRAINT 이름] REFERENCES 참초테이블명 [(참조할 컬럼명)]
-- 테이블레벨에서 설정
-- [CONSTRAINT 이름] FOREIGN KEY (적용할 컬럼명) REFERENCES 참조테이블 [(참조컬럼명)]
-- NULL은 사용할 수 있음, 제공되지 않는 값을 쓸 수 없다!!!!!

CREATE TABLE TESTFK (
    EMP_ID CHAR(3) REFERENCES EMPLOYEE, 
    -- 참조 컬럼명이 생략되면 PRIMARY KEY 컬럼이 자동 연결됨
    DEPT_ID CHAR(2) CONSTRAINT TFK_DID REFERENCES DEPARTMENT (DEPT_ID),
    JOB_ID CHAR(2),
    -- 테이블레벨
    CONSTRAINT TFK_JID FOREIGN KEY (JOB_ID) REFERENCES JOB (JOB_ID)
);

-- 기록 테스트
-- 연결된 테이블에 연결된 컬럼에 기록되어 있는 값만 사용할 수 있음
INSERT INTO TESTFK VALUES('300', NULL, NULL); -- ERROR : 300이라는 사번이 EMPLOYEE에 없음, 제공되지 않는 값 사용
-- integrity constraint (STUDENT.SYS_C007202) violated - parent key not found
INSERT INTO TESTFK VALUES('100', NULL, NULL);
INSERT INTO TESTFK VALUES('200', '70', NULL); -- 제공되지 않는 부서코드 사용해서 에러 남
INSERT INTO TESTFK VALUES('200', '90', NULL);
INSERT INTO TESTFK VALUES('124', '80', 'J9'); -- 제공되지 않는 직급코드 사용해서 에러 남
INSERT INTO TESTFK VALUES('124', '80', 'J7');

SELECT * FROM TESTFK;

-- 외래키 제약조건에서 PARENT KEY가 될 수 있는 컬럼은 
-- PRIMARY KEY 또는 UNIQUE 제약조건이 설정된 컬럼만 참조 컬럼이 될 수 있다.

CREATE TABLE NOPK(
    ID CHAR(3),
    NAME VARCHAR2(10)
);

CREATE TABLE TESTFK2 (
    FID CHAR(3) REFERENCES NOPK (ID), -- referenced table does not have a primary key
    FNAME VARCHAR2(10)
);


CREATE TABLE TESTUN5(
    ID CHAR(3) UNIQUE,
    NAME VARCHAR2(10)
);

CREATE TABLE TESTFK2 (
    FID CHAR(3) REFERENCES TESTUN5 (ID), 
    FNAME VARCHAR2(10)
);

-- 복합키 설정
-- 여러 개의 컬럼을 묶어서 UNIQUE 제약조건이나 PRIMARY KEY 제약조건을
-- 설정한 복합키를 참조할 경우
CREATE TABLE TEST_COMPLEX (
    ID NUMBER,
    NAME VARCHAR2(10),
    UNIQUE (ID, NAME) -- 두개를 하나로 본다, NULL 입력 가능,
);

INSERT INTO TEST_COMPLEX VALUES (100, 'ORACLE');
INSERT INTO TEST_COMPLEX VALUES (NULL, NULL);
INSERT INTO TEST_COMPLEX VALUES (NULL, NULL);
INSERT INTO TEST_COMPLEX VALUES(100, NULL);
INSERT INTO TEST_COMPLEX VALUES(NULL, 'ORACLE');
INSERT INTO TEST_COMPLEX VALUES (100, 'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL, 'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL, 'JAVA'); -- ERROR
INSERT INTO TEST_COMPLEX VALUES (100, 'JAVA'); -- ERROR

SELECT * FROM TEST_COMPLEX;

-- 복합키를 참조키로 설정할 경우
CREATE TABLE TESTFK4 (
    ID NUMBER,
    NAME VARCHAR2(10),
    PRICE NUMBER,
    FOREIGN KEY (ID, NAME) REFERENCES TEST_COMPLEX  (ID, NAME)
);

-- 복합키로 설정된 참조컬럼은 따로 외래키 설정을 할 수 없다
CREATE TABLE TESTFK5 (
    ID NUMBER REFERENCES TEST_COMPLEX (ID),
    NAME VARCHAR2(10) REFERENCES TEST_COMPLEX (NAME),
    PRICE NUMBER--,
    -- FOREIGN KEY (ID) REFERENCES TEST_COMPLEX  (ID, NAME)
    -- ERROR
);

-- 외래키가 설정된 컬럼에 값이 사용 중이면, 부모키는 절대 삭제할 수 없음.
DELETE FROM DEPARTMENT 
WHERE DEPT_ID = '90'; -- ERROR : integrity constraint (STUDENT.FK_DEPTID) violated - child record found
-- EMPLOYEE 테이블에 DEPT_ID 컬럼에 '90' 사용되고 있음 : CHILD RECORD가 있기 때문에 부모 키를 삭제할 수가 없다

-- FOREIGN KEY 제약조건 설정시 삭제옵션을 추가할 수 있음 : DELETION OPTION
-- 기본은 자식레코드가 존재하면 부모키는 삭제 불가능(RESTRICTED, 절대 삭제 못함)
-- FOREIGN KEY 제약조건을 생성할 때, 참조 컬럼 값이 삭제되는 경우 FOREIGN KEY 컬럼 값을 어떻게 처리할 지 지정 가능
-- ON DELETE SET NULL, ON DELETE CASCADE

-- ON DELETE SET NULL 추가
-- 부모 키가 삭제 될 때 자식 레코드 값을 NULL로 바꿔라
CREATE TABLE PRODUCT_STATE (
    PSTATE CHAR(1) PRIMARY KEY,
    PCOMMENT VARCHAR2(10)
);

INSERT INTO PRODUCT_STATE VALUES ('A', '최고급');
INSERT INTO PRODUCT_STATE VALUES ('B', '보통');
INSERT INTO PRODUCT_STATE VALUES ('C', '저급');

SELECT * FROM PRODUCT_STATE;

CREATE TABLE PRODUCT(
    PNAME VARCHAR2(20) PRIMARY KEY,
    PPRICE NUMBER CHECK (PPRICE > 0),
    PSTATE CHAR(1) REFERENCES PRODUCT_STATE (PSTATE) ON DELETE SET NULL
);

INSERT INTO PRODUCT VALUES ('갤럭시', 653000, 'A');
INSERT INTO PRODUCT VALUES ('G7', 740000, 'B');
INSERT INTO PRODUCT VALUES ('맥북', 2500000, 'C');

SELECT * FROM PRODUCT;

-- 삭제 테스트
DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'A';

COMMIT;

SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_STATE;

-- ON DELETE CASCADE
-- 제공되는 부모 키가 삭제되면, 제공 값을 사용하는 자식 레코드도 함께 삭제
CREATE TABLE PRODUCT2 (
    PNAME VARCHAR2(20) PRIMARY KEY,
    PPRICE NUMBER CHECK (PPRICE > 0),
    PSTATE CHAR(1) REFERENCES PRODUCT_STATE ON DELETE CASCADE
);

INSERT INTO PRODUCT2 VALUES ('맥북', 2500000, 'B');
INSERT INTO PRODUCT2 VALUES ('맥에어', 1250000, 'C');

SELECT * FROM PRODUCT2;

DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'B';

COMMIT;

SELECT * FROM PRODUCT_STATE;
SELECT * FROM PRODUCT2;

CREATE TABLE TABLE_SUBQUERY1
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
    FROM EMPLOYEE
    LEFT JOIN DEPARTMENT USING (DEPT_ID)
    LEFT JOIN JOB USING (JOB_ID);

SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
    FROM EMPLOYEE
    LEFT JOIN DEPARTMENT USING (DEPT_ID)
    LEFT JOIN JOB USING (JOB_ID);

SELECT * FROM TABLE_SUBQUERY1;

-- DESCRIBE 테이블;
-- 테이블의 구조를 확인하는 명령어
DESCRIBE TABLE_SUBQUERY1;
DESC TABLE_SUBQUERY1;

-- 직원 테이블에서 90번 부서에 소속된 직원 정보만 따로 EMP_COPY90 테이블에 저장
CREATE TABLE EMP_COPY90
AS SELECT *
    FROM EMPLOYEE
    WHERE DEPT_ID = '90';
    
SELECT * FROM EMP_COPY90;   
DESC EMP_COPY90;

-- 복사본 테이블 만들기
CREATE TABLE EMP_COPY
AS SELECT *
    FROM EMPLOYEE;

SELECT * FROM EMP_COPY;    
DESC EMP_COPY;
-- 서브쿼리를 이용해서 기존 테이블을 복사할 경우 : 컬럼명, 자료형, NOT NULL 제약조건, 값은 그대로 복사가 된다.
-- 나머지 제약조건들은 복사되지 않음

-- 제약조건 관련 DATA DICTIONARY 확인
-- USER_CONSTRAINTS 
SELECT * FROM USER_CONSTRAINTS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_COPY';


-- 실습 1.
-- 사번, 이름, 급여, 직급명, 부서명, 근무지역명, 소속국가명 조회
-- 조회 결과를 EMP_LIST 테이블에 저장

SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN LOCATION ON (LOC_ID = LOCATION_ID)
LEFT JOIN COUNTRY USING(COUNTRY_ID);

CREATE TABLE EMP_LIST
AS 
SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN LOCATION ON (LOC_ID = LOCATION_ID)
LEFT JOIN COUNTRY USING(COUNTRY_ID);

-- 실습 2.
-- EMPLOYEE 테이블에서 남자 직원의 정보만 조회해서
-- EMP_MAN 테이블에 저장

SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = '1';

CREATE TABLE EMP_MAN
AS 
SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = '1';

-- 실습 3.
-- 여자 직원의 정보만 조회해서, EMP_FEMAIL 테이블에 저장함.

SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = '2';

CREATE TABLE EMP_FEMAIL
AS 
SELECT *
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = '2';

-- 실습 4.
-- 부서별 직원 명단을 정리해서 PART_LIST 테이블에 저장
-- DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID로 컬럼 구성함
-- 컬럼에 주석 달기

SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM DEPARTMENT
RIGHT JOIN EMPLOYEE USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
ORDER BY 1;
CREATE TABLE PART_LIST
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM DEPARTMENT
RIGHT JOIN EMPLOYEE USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
ORDER BY 1;

COMMENT ON COLUMN PART_LIST.DEPT_NAME IS '부서명';
COMMENT ON COLUMN PART_LIST.JOB_TITLE IS '직급명';
COMMENT ON COLUMN PART_LIST.EMP_NAME IS '사원명';
COMMENT ON COLUMN PART_LIST.EMP_ID IS '사번';

SELECT * FROM PART_LIST
ORDER BY 3;
